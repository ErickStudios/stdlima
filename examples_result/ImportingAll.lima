/**
What happen if i import all modules?
**/
/**
dmemo.lima
Dynamic MEMory Organization
**/
/**
Pool_t
represents a pool
**/
@structure
{
	prototype
    int
    var
        Start
    prototype
    int
    var
        End
}
Pool_t
;
/**
Malloc
allocates a memory pool that starts in @param:start and have a lenght of @param:size
and the result is saved in the pointer of the @param:variable
_returned = start of the pool
@ax = the end of the pool
**/
section
Malloc
    /**
    configure vars
    **/
    mov
        _returned
        start
    var
        end
        =
        start
    var
        end
        +=
        size
    mov
        @ax
        end
    ustruct
        *variable
        Pool_t
    var
        *variable(+)"->Start"
        =
        @ScratchVar(_returned)
    var
        *variable(+)"->End"
        =
        @ScratchVar(@ax)
popback
# doc.lima
#
# abstract:
#   provides a docummentation extensive tools
///! ![enable Lima++]
///! !pragma once
%define _In_ NULL
%define _Out_ NULL
%define _Optional_ NULL
%define _Obligatory_ NULL
%define _Unused_ NULL
%define _Obsolete_ NULL
%define _ForCompatibility_ NULL
%define IN NULL
%define OUT NULL
%define OPTIONAL NULL
%define OBLIGATORY NULL
%define UNUSED NULL
%define OBSOLETE NULL
%define FORCOMPATIBILITY NULL
# eception.lima
#
# abstract:
#   lima execptions
///! ![enable Lima++]
///! ![Lima++ no_main]
///! ![Lima++ no_std]
///! ![Lima++ std_lib_definition]
///! ![Lima++ jump affter execution]
# stdbase.lima
# the base std module
///! ![enable Lima++]
///! !pragma once
/**
check if callback
**/
if
(
    std->module
    ==
    "std->module"
)
{
    proto module "std"
}
/**
* Exception
*
* represents a exception of the Lima++
**/
collection<class Eception>
{
    /**
    * close
    *
    * if the program closes when the exception ocurred
    **/
    declare var<close>: boolean
    /**
    * code
    *
    * the code of the exception
    **/
    declare var<code>: any
    /**
    * constructor
    *
    * declares the constructor, is used later
    **/
    collection<function constructor>
    (
        /**
        code: represents the code when the exception ocurred
        **/
        collection<param code>
        /**
        close: represents if close the program when the exception ocurred
        **/
        collection<param close>
    )
        /**
        check firs one things
        **/
        if
        (
            typeof collection<param close>
            !=
            boolean
        )
        {
            section
            .xd
            jump
            .xd
        }
        /**
        configure the variables
        **/
        var
            (this)->close 
            = 
            collection<param close>
        var
            (this)->code 
            = 
            collection< paramcode>
    collection<end function>
    /**
    * call
    *
    * this calls to the exception
    **/
    collection<function call>
    (
    )
        /**
        configure variables
        **/
        var
            code
            =
            (this)->code
        var
            close
            =
            (this)->close
        /**
        make the exception
        **/
        echo "an exception has been ocurred: "(..)code
        var
            .cnd
            (close==true)
        jt
            .loop
        __endprog__
        /**
        the close loop
        **/
        section
        .loop
        jump
        .loop
    collection<end function>
}
/**
* QuickException
*
* makes a fast exception
**/
[intersegmental]
message QuickException
    collection<new class?Eception exception>
[endmsg]
/**
files.lima
a easy form to managen files
**/
///! ![enable Lima++]
/**
FileInfo
represents a file
**/
collection<class FileInfo>
{
    /**
    name
    the name of the file
    **/
    declare var<name>: text
    /**
    content
    the content of the file
    **/
    declare var<content>: any
    /**
    path
    the path of the
    **/
    declare var<path>: text
    /**
    IsOpen
    if the file is opened
    **/
    declare var<IsOpen>: boolean
    /**
    open_file
    open the file
    **/
    collection<function open_file>
    (
    )
        mov
            @eax
            "/file getconent -n"
        mov
            @bx
            (this)->name
        %^"!p"
        var
            (this)->content
            =
            _returned
        var
            (this)->IsOpen
            =
            true
        if
        (
            _returned
            ==
            "??wtf??"
        )
        {
            var
                (this)->IsOpen
                =
                false
        }
    collection<end function>
}
# iostream.lima
///! ![enable Lima++]
///! !pragma once
# basic_iostream
# 
# Summary:
# 	represents the console functions to interact with the input/outpud system of the console
#   line, includes print, printw, read, readkey, readline, readlinenv
#
#   example1:
#       collection<new class?string phrase>
#       =
#       "hello world"
#
#       NULL collection<instance;class?basic_iostream;conout;print>(->)<phrase>
#
#   example2
#       collection<new class?string ky>
#       =
#       collection<instance;class?basic_iostream;conin;readline>(->)<>
#   
#   in the examples you view a collection<instance;class?basic_iostream>, this represents a function to acces to
#   the Lima++ functions
#       collection = Lima functions
#           instance = extract a function for the instance class?basic_iostream that is instanced as conin/conout
#           conin/conout = the variables of the instances that are instanced as the class basic_iostream
#           readline/print = the functions to extract
#       (->) = a method for acces to propietys or functions of varius objects
#           <> = represents the opening and the closing of the params to send to the function
#               phrase (in the <>) = represents the variable (or the param) to send
#  
#
# Params:
# 	nothing for init
#
# Subroutines:
#   print: prints a text
#   printw: prints a text without a line feed
#   read: read the line (the built-in interpreter function)
#   readkey: read a key (with a built-in interpreter function)
#   readline: read but this version is not built-in, perfect for study the behavior of the read function
#   readlinenv: readline but without a preview of the actions make of the user (the keys presed)
#
# warnings:
#   in collection<instance;class?basic_iostream;conin;readline>(->)<> use the spaces and not the ; in the syntax are
#   dangreus for the use , because in this form the lima interpreter dont know what action is
#   and for compatibility with the interpreter commands that managen two or more argumments and for dont break it
#   dont use spaces , use ; and in the strings use "%sp" for the spaces in the strings
# 
collection<class basic_iostream>
{
    # __value
    # 
    # Summary:
    # 	the value that is called when you try to call the class
    # 
    collection<children var __value>
    # print
    # 
    # Summary:
    # 	prints a text
    # 
    # Params:
    # 	...
    # 
    collection<function print>
    (
        collection<param text>
    )
        echo collection<param text>
        collection<return "">
    collection<end function>
    # printw
    # 
    # Summary:
    # 	prints a text (without a line jump)
    # 
    # Params:
    # 	...
    # 
    collection<function prinprintwt>
    (
        collection<param text>
    )
        writel collection<param text>
        collection<return "">
    collection<end function>
    # read
    # 
    # Summary:
    # 	read a line
    # 
    # Params:
    # 	...
    # 
    collection<function read>
    (
    )
        collection<return ReadLine>
    collection<end function>
    # readkey
    # 
    # Summary:
    # 	read a key
    # 
    # Params:
    # 	...
    # 
    collection<function readkey>
    (
    )
        collection<return ReadKeyWait>
    collection<end function>
    # readline
    # 
    # Summary:
    # 	a manual form to read the line (with a preview view of the line)
    # 
    # Params:
    # 	...
    # 
    collection<function readline>
    (
    )
        #
        # configure vars
        #
        # line
        # 
        # Summary:
        # 	the line writed
        #
        var
            line
            =
            ""
        # key
        # 
        # Summary:
        # 	the pressed key
        #
        var
            key
            =
            ""
        jump
        .loop
        # loop
        # 
        # Summary:
        # 	loop for the line reading loop
        #   this gets a key pressed by the user and 
        #   adds or backspace or returns the line
        # 
        # Params:
        # 	@key: the variable of the leu
        #         necesary for the logic
        #   @line: the line for read and shift, cat or return
        # 
        section
        .loop
            # 
            # gets the key
            #
            var
                key
                =
                ReadKeyWait
            #
            # key logic
            #
            # set the conditional variable
            var
                .cnd
                =
                (key=="enter")
            # if the enter key is pressed ends the line
            jt
            .end
            # if not continue with the key pulsation
            jf
            .pulse
        # in some cases the pulse fails and for this cases make a recovery point
        jump
        .loop
        # pulse
        # 
        # Summary:
        # 	the pulsation logic for the keys
        # 
        # Params:
        # 	@key: the key to add/backspace it
        #   @line: the line
        # 
        section
        .pulse
            #
            # check if the key is backspace
            #
            var
                .cnd
                =
                (key=="backspace")
            # if true , shift the text
            jt
            .backspace
            # if false add the character to the line
            var
                line
                StrCat=
                key
            # a preview
            writel key
        # next key
        jump
        .loop
        # backspace
        # 
        # Summary:
        # 	the backspace logic
        # 
        # Params:
        # 	@line: the line
        # 
        section
        .backspace
            var
                line
                -=
                1
            # backspace the key
            shiftcur -1 0
            writel " "
            shiftcur -1 0
        # next key
        jump
        .loop
        # end
        # 
        # Summary:
        # 	the end of the function
        # 
        # Params:
        # 	...
        # 
        section
        .end
        echo ""
        collection<return line>
    collection<end function>
    # readlinenv
    # 
    # Summary:
    # 	a manual form to read the line (without a preview view of the line)
    # 
    # Params:
    # 	...
    # 
    collection<function readlinenv>
    (
    )
        #
        # configure vars
        #
        # line
        # 
        # Summary:
        # 	the line writed
        #
        var
            line
            =
            ""
        # key
        # 
        # Summary:
        # 	the pressed key
        #
        var
            key
            =
            ""
        jump
        .loop
        # loop
        # 
        # Summary:
        # 	loop for the line reading loop
        #   this gets a key pressed by the user and 
        #   adds or backspace or returns the line
        # 
        # Params:
        # 	@key: the variable of the leu
        #         necesary for the logic
        #   @line: the line for read and shift, cat or return
        # 
        section
        .loop
            # 
            # gets the key
            #
            var
                key
                =
                ReadKeyWait
            #
            # key logic
            #
            # set the conditional variable
            var
                .cnd
                =
                (key=="enter")
            # if the enter key is pressed ends the line
            jt
            .end
            # if not continue with the key pulsation
            jf
            .pulse
        # in some cases the pulse fails and for this cases make a recovery point
        jump
        .loop
        # pulse
        # 
        # Summary:
        # 	the pulsation logic for the keys
        # 
        # Params:
        # 	@key: the key to add/backspace it
        #   @line: the line
        # 
        section
        .pulse
            #
            # check if the key is backspace
            #
            var
                .cnd
                =
                (key=="backspace")
            # if true , shift the text
            jt
            .backspace
            # if false add the character to the line
            var
                line
                StrCat=
                key
        # next key
        jump
        .loop
        # backspace
        # 
        # Summary:
        # 	the backspace logic
        # 
        # Params:
        # 	@line: the line
        # 
        section
        .backspace
            var
                line
                -=
                1
        # next key
        jump
        .loop
        # end
        # 
        # Summary:
        # 	the end of the function
        # 
        # Params:
        # 	...
        # 
        section
        .end
        echo ""
        collection<return line>
    collection<end function>
}
# conin
# 
# Summary:
# 	the console input built-in libary protocol
# 
collection<new class?basic_iostream conin>
=
<instance class<"in">>
# conout
# 
# Summary:
# 	the console outpud built-in libary protocol
# 
collection<new class?basic_iostream conout>
=
<instance class<"out">>
/**
loops.lima
defines the loops
**/
///! !pragma once
jump
.post_loop_lib
/**
for_loop
the for loop
@param Variable: the pointer to the variable
@param Start: the start value
@param Max: the max number that can touch the Variable:@param
@param code: the code to execute in each literation
**/
section
for_loop
var
    *Variable
    =
    Start
jump
.floop_st
section
.floop_st
var
    .cnd
    (Pointer(*Variable)==Max)
jt
    .floop_end
lex code
var
    *Variable
    +=
    1
jump
.floop_st
section
.floop_end
popback
section
.post_loop_lib
/**
map.lima
provides a form to make arrays/jsons in lima
**/
///! ![enable Lima++]
///! ![Lima++ no_main]
///! ![Lima++ no_std]
///! ![Lima++ std_lib_definition]
///! ![Lima++ jump affter execution]
/**
* Map
* 
* represents a map of string
*
**/
collection<class Map>
{
    /**
    * init
    *
    * initializes the map
    **/
    collection<function init>
    (
    )
        var
            collection<get __value>
            =
            ""
    collection<end function>
    /**
    * transfer
    *
    * coppy the array to a other variable
    **/
    collection<function transfer>
    (
        /**
        variable
        the variable to transfer all keys
        **/
        collection<param variable>
    )
        /**
        first coppy the key list
        **/
        echo collection<get __value>
        var
            collection<param variable>
            =
            collection<get __value>
        /**
        now coppy the enterly array
        **/
        mov
            @eax
            "/array icount"
        mov
            @bx
            collection<get __value>
        %^"!p"
        var
            count
            =
            _returned
        section
        .loop
        var
            .cnd
            =
            (count==0)
        jt
        .more
        __endprog__
        section
        .more
        var
            get -> "collection<param variable>"(..)"->["(..)"collection<get __value>"(->)[count]
            =
            GetVar("(this)->["(..)(this)(->)[count](..)"]")
        var
            count
            -=
            1
        jump
        .loop
    collection<end function>
    /**
    * this;item
    *
    * represents a function to acces to the keys
    **/
    collection<function item>
    (
        /**
        Key
        the key to get
        **/
        collection<param Key>
    )
        /**
        configure vars
        **/
        var
            value
            =
            (this)[collection<param Key>]
        collection<return value>
    collection<end function>
    /**
    * this;itemset=
    *
    * assings a value
    **/
    collection<function itemset=>
    (
        collection<param Key>
        collection<param Value>
    )
        /**
        configure vars
        **/
        var
            (this)[collection<param Key>]
            =
            collection<param Value>
        /**
        ckeck if the key is not created
        **/
        mov
            @eax
            "/array ContainsValue"
        mov
            @ax
            collection<param Key>
        mov
            @bx
            (this)
        %^"!p"
        if
        (
            _returned
            =
            false
        )
        {
            mov
                @eax
                "/array Add"
            mov
                @ax
                collection<param Key>
            mov
                @bx
                (this)
            %^"!p"
            var
                (this)
                =
                _returned
        }
    collection<end function>
}
# math.lima
///! ![enable Lima++]
///! !pragma once
///! ![enable Lima++]
collection<class basic_mathstream>
{
    # __value
    # 
    # Summary:
    # 	the value that is called when you try to call the class
    # 
    collection<children var __value>
    /**
    pow
    power math
    **/
    collection<function pow>
    (
        collection<param number>
        collection<param exponent>
    )
        /**
        configure vars
        **/
        var
            result
            =
            collection<param number>
        var
            num
            =
            collection<param number>
        var
            exp
            =
            collection<param exponent>
        /**
        make the operation
        **/
        var
            i
            =
            1
        section
        .loop
        var
            .cnd
            =
            (i!=exp)
        jt
            .sm
        collection<return result>
        section
        .sm
            var
                result
                *=
                num
            var
                i
                +=
                1
        jump
        .loop
    collection<end function>
}
collection<new class?basic_mathstream MathLib>
=
NULL
# reylab.lima
#
# abstract:
#   raylib for lima (reylab for avoid coppyright)
///! ![enable Lima++]
/**
basic_grapichsstream_enum
represents the 16 posibles colors that a pixel can draw
**/
@structure
{
	prototype
    0
    var
        Black
    prototype
    1
    var
        DarkBlue
    prototype
    2
    var
        DarkGreen
    prototype
    3
    var
        DarkCyan
    prototype
    4
    var
        DarkRed
    prototype
    5
    var
        DarkMagenta
    prototype
    6
    var
        DarkYellow
    prototype
    7
    var
        Gray
    prototype
    8
    var
        DarkGray
    prototype
    9
    var
        Blue
    prototype
    10
    var
        Green
    prototype
    11
    var
        Cyan
    prototype
    12
    var
        Red
    prototype
    13
    var
        Magenta
    prototype
    14
    var
        Yellow
    prototype
    15
    var
        White
}
basic_grapichsstream_enum
;
/**
basic_grapichsstream
a grapichs manager for the console outpud
**/
collection<class basic_grapichsstream>
{
    /**
    constructor
    the init of class
    **/
    collection<function constructor>
    (
        # none
    )
    collection<end function>
    /**
    render_pixel
    render a pixel
    **/
    collection<function render_pixel>
    (
        /**
        x: the x position (in console lines/rows)
        **/
        collection<param x>
        /**
        y: the y position (in console lines/rows)
        **/
        collection<param y>
        /**
        color: the color of the pixel
        **/
        collection<param color>
    )
        gotoxy collection<param x> collection<param y>
        color 0 collection<param color>
        writel " "
    collection<end function>
}
# for the users that prefers the library name
collection<new class?basic_grapichsstream reylab>
=
NULL
/**
aliases for common contexts
**/
# for gnu-efi users
collection<new class?basic_grapichsstream GrapichsOutpudProtocol>
=
NULL
# other for gnu-efi users
collection<new class?basic_grapichsstream GOP>
=
NULL
# his realname
collection<new class?basic_grapichsstream ConGrapichs>
=
NULL
ustruct
    reylab->PixelColor
    basic_grapichsstream_enum
# stdbase.lima
# the base std module
///! ![enable Lima++]
///! !pragma once
/**
check if callback
**/
if
(
    std->module
    ==
    "std->module"
)
{
    proto module "std"
}
# stdlib.lima
# library for using lima functions for begimmers
# include only stdlib and is all
# file not founded
# file not founded
# string.lima
#
# abstract:
#   string clases
///! ![enable Lima++]
///! ![Lima++ no_main]
///! ![Lima++ no_std]
///! ![Lima++ std_lib_definition]
///! ![Lima++ jump affter execution]
# stdbase.lima
# the base std module
///! ![enable Lima++]
///! !pragma once
/**
check if callback
**/
if
(
    std->module
    ==
    "std->module"
)
{
    proto module "std"
}
/**
string_types
defines the types of the strings
**/
@structure
{
	prototype
    ""
    var
        EmptyString
}
string_types
;
ustruct
    StringTypes
    string_types
/**
* string
* 
* represents a string
* a string is a text for represents
*
**/
collection<class string>
{
    # __value
    # 
    # Summary:
    # 	the value that is called when you try to call the class
    # 
    collection<children var __value>
    # lenght
    # 
    # Summary:
    # 	the lenght of the text
    # 
    collection<children var <class_name>->lenght>
    /**
    * Join
    * 
    * Joins a text
    *
    **/
    collection<function Join> 
    (
        /**
        text2
        the text to join with the other
        **/
        collection<param text2>
        )
            #
            # setuping variables
            #
            var
                text
                =
                collection<get __value>
            var
                text2
                =
                collection<param text2>
            #
            # routine
            #
            var
                _returned
                =
                text
            var
                _returned
                +=
                text2
            collection<return _returned>
            collection<set __value> _returned
    collection<end function>
}
/**
UiProt.lima
ui protocol tools, but for console/CLI
**/
///! ![enable Lima++]
var
    GlobalTab
    =
    0
/**
UIFrameColor
represents the 16 posibles colors that a color can set
**/
@structure
{
    /**
    Black
    represents the color Black
    **/
	prototype
    0
    var
        Black
    /**
    DarkBlue
    represents the color Dark Blue
    **/
    prototype
    1
    var
        DarkBlue
    /**
    DarkGreen
    represents the color Dark Green
    **/
    prototype
    2
    var
        DarkGreen
    /**
    DarkCyan
    represents the color Dark Cyan
    **/
    prototype
    3
    var
        DarkCyan
    /**
    DarkRed
    represents the color Dark Red
    **/
    prototype
    4
    var
        DarkRed
    /**
    DarkMagenta
    represents the color Dark Magenta
    **/
    prototype
    5
    var
        DarkMagenta
    /**
    DarkYellow
    represents the color Dark Yellow
    **/
    prototype
    6
    var
        DarkYellow
    /**
    Gray
    represents the color Gray
    **/
    prototype
    7
    var
        Gray
    /**
    DarkGray
    represents the color Dark Gray
    **/
    prototype
    8
    var
        DarkGray
    /**
    Blue
    represents the color Blue
    **/
    prototype
    9
    var
        Blue
    /**
    Green
    represents the color Green
    **/
    prototype
    10
    var
        Green
    /**
    Cyan
    represents the color Cyan
    **/
    prototype
    11
    var
        Cyan
    /**
    Red
    represents the color Red
    **/
    prototype
    12
    var
        Red
    /**
    Magenta
    represents the color Magenta
    **/
    prototype
    13
    var
        Magenta
    /**
    Yellow
    represents the color Yellow
    **/
    prototype
    14
    var
        Yellow
    /**
    White
    represents the color White
    **/
    prototype
    15
    var
        White
}
UIFrameColor
;
ustruct
    GUIColors
    UIFrameColor
/**
IHBCanvas
represents the interface that contains the manage thins
**/
collection<class IHBCanvas>
{
    /**
    Tab
    the current tab managen
    **/
    declare var<Tab>: any
}
/**
IElementGUI
represents the interface of the ui elements
**/
collection<class IElementGUI>
{
    /**
    XPos
    represents the x position of the object
    **/
    declare var<XPos>: number
    /**
    YPos
    represents the y position of the object
    **/
    declare var<YPos>: number
    /**
    Hidden
    if the object is not visible
    **/
    declare var<Hidden>: boolean
}
/**
UIFrame
represents a frame
**/
collection<class UIFrame>
{
    /**
    declare it as a class expansible of IElementGUI (its a type of herence)
    **/
    expand class IElementGUI
    /**
    SizeX
    the X size of the frame
    **/
    declare var<FSizeX>: number
    /**
    SizeY
    the Y size of the frame
    **/
    declare var<FSizeY>: number
    /**
    Background
    the background color of the frame
    **/
    declare var<Background>: number
}
/**
UIRectangle
a ui rectangle (is a UIFrame but, drawable)
**/
collection<class UIRectangle>
{
    expand class UIFrame
    /**
    Draw
    draw the Rectangle
    **/
    collection<function Draw>
    (
    )
        /**
        configure variables
        **/
        var
            XPosition
            =
            (this)->XPos
        var
            YPosition
            =
            (this)->YPos
        var
            IsHidden
            =
            (this)->Hidden
        var
            SizeX
            =
            (this)->FSizeX
        var
            SizeY
            =
            (this)->FSizeY
        var
            Background
            =
            (this)->Background
        /**
        configure the drawable text
        **/
        var
            Drawable
            =
            " "
        var
            Drawable
            Repeat=
            SizeX
        var
            Drawable
            StrCat=
            %internal.linefeed
        var
            Drawable
            Repeat=
            SizeY
        gotoxy XPosition YPosition
        color 0 Background
        echo Drawable
    collection<end function>
}
/**
UIText
a ui text element
**/
collection<class UITextLabel>
{
    expand class UIFrame
    /**
    TextLabel
    the text label text
    **/
    declare var<TextLabel>: text
    /**
    Foreground
    the foreground color of the 
    **/
    declare var<Foreground>: number
}
/**
UIText
a ui text element
**/
collection<class UIText>
{
    expand class UITextLabel
    /**
    Draw
    draw the text
    **/
    collection<function Draw>
    (
    )
        /**
        configure variables
        **/
        var
            XPosition
            =
            (this)->XPos
        var
            YPosition
            =
            (this)->YPos
        var
            IsHidden
            =
            (this)->Hidden
        var
            SizeX
            =
            (this)->FSizeX
        var
            SizeY
            =
            (this)->FSizeY
        var
            Background
            =
            (this)->Background
        var
            Foreground
            =
            (this)->Foreground
        var
            Text
            =
            (this)->TextLabel
        /**
        configure the drawable text
        **/
        var
            Drawable
            =
            " "
        var
            Drawable
            Repeat=
            SizeX
        var
            Drawable
            StrCat=
            %internal.linefeed
        var
            Drawable
            Repeat=
            SizeY
        color 0 Background
        gotoxy XPosition YPosition
        echo Drawable
        color Foreground Background
        echo Text
    collection<end function>
}
/**
IElementButtonUI
represents a UI button interface
**/
collection<class IElementButtonUI>
{
    /**
    Code
    the code that is executed when you click the button
    **/
    declare var<Code>: any
    /**
    tab_id
    the id of the button in the tabulator
    **/
    declare var<tab_id>: number
}
/**
UITextButton
represents a text button
**/
collection<class UITextButton>
{
    expand class UITextLabel
    expand class IElementButtonUI
    /**
    HoverBackground
    the background when the button is hoverd
    **/
    declare var<HoverBackground>: number
    /**
    HoverForeground
    the foreground when the button is hoverd
    **/
    declare var<HoverForeground>: number
    /**
    Draw
    draw the text
    **/
    collection<function Draw>
    (
        /**
        Tab
        the current tab to check if select the button
        **/
        collection<param Tab>
    )
        /**
        configure variables
        **/
        var
            XPosition
            =
            (this)->XPos
        var
            YPosition
            =
            (this)->YPos
        var
            IsHidden
            =
            (this)->Hidden
        var
            SizeX
            =
            (this)->FSizeX
        var
            SizeY
            =
            (this)->FSizeY
        var
            Background
            =
            (this)->Background
        var
            Foreground
            =
            (this)->Foreground
        var
            HBackground
            =
            (this)->HoverBackground
        var
            HForeground
            =
            (this)->HoverForeground
        var
            Text
            =
            (this)->TextLabel
        var
            TabID
            =
            (this)->tab_id
        /**
        configure the drawable text
        **/
        var
            Drawable
            =
            " "
        var
            Drawable
            Repeat=
            SizeX
        var
            Drawable
            StrCat=
            %internal.linefeed
        var
            Drawable
            Repeat=
            SizeY
        color 0 Background
        if
        (
            collection<param Tab>
            ==
            TabID
        )
        {
            color 0 HBackground
        }
        gotoxy XPosition YPosition
        echo Drawable
        color Foreground Background
        if
        (
            collection<param Tab>
            ==
            TabID
        )
        {
            color HForeground HBackground
        }
        echo Text
    collection<end function>
    /**
    GoTo
    **/
    collection<function GoTo>
    (
    )
        lex (this)->Code
    collection<end function>
}
/**
UIRectangleButton
represents a rectangle button
**/
collection<class UITextButton>
{
    expand class UIFrame
    expand class IElementButtonUI
    /**
    HoverBackground
    the background when the button is hoverd
    **/
    declare var<HoverBackground>: number
    /**
    HoverForeground
    the foreground when the button is hoverd
    **/
    declare var<HoverForeground>: number
    /**
    Draw
    draw the text
    **/
    collection<function Draw>
    (
        /**
        Tab
        the current tab to check if select the button
        **/
        collection<param Tab>
    )
        /**
        configure variables
        **/
        var
            XPosition
            =
            (this)->XPos
        var
            YPosition
            =
            (this)->YPos
        var
            IsHidden
            =
            (this)->Hidden
        var
            SizeX
            =
            (this)->FSizeX
        var
            SizeY
            =
            (this)->FSizeY
        var
            Background
            =
            (this)->Background
        var
            Foreground
            =
            (this)->Foreground
        var
            HBackground
            =
            (this)->HoverBackground
        var
            HForeground
            =
            (this)->HoverForeground
        var
            Text
            =
            (this)->TextLabel
        var
            TabID
            =
            (this)->tab_id
        /**
        configure the drawable text
        **/
        var
            Drawable
            =
            " "
        var
            Drawable
            Repeat=
            SizeX
        var
            Drawable
            StrCat=
            %internal.linefeed
        var
            Drawable
            Repeat=
            SizeY
        color 0 Background
        if
        (
            collection<param Tab>
            ==
            TabID
        )
        {
            color 0 HBackground
        }
        gotoxy XPosition YPosition
        echo Drawable
        color Foreground Background
    collection<end function>
    /**
    GoTo
    **/
    collection<function GoTo>
    (
    )
        lex (this)->Code
    collection<end function>
}
/**
UIGui
represents a GUI interface
**/
collection<class UIGui>
{
    expand class IHBCanvas
    /**
    Items
    the items in the gui
    **/
    declare var<Items>: <class IElementGUI>[]
    /**
    Launch
    launchs the GUI
    **/
    collection<function Launch>
    (
    )
    collection<end function>
    /**
    AppendNewElement
    appends a new GUI item
    **/
    collection<function AppendNewElement>
    (
        /**
        ItemPointer
        the variable of the item where the element is instanced
        **/
        collection<param ItemPointer>
    )
    var
        (this)->Items
        Line+=
        collection<param ItemPointer>
    collection<end function>
}
/**
AppGUI
represents the global interface for all the application
**/
collection<new class?UIGui AppGUI>
=
NULL
/**
xml.lima
functions to managen xmls
**/
///! ![enable Lima++]
/**
XmlFunctions
represents the xml functions
**/
collection<class XmlFunctions>
{
    /**
    parse_tag
    parse a tag with value and that things
    **/
    collection<function parse_tag>
    (
        /**
        tag_e
        the tag text
        **/
        collection<param tag_e>
        /**
        variable
        the pointer to the variable to redirect the outpud
        **/
        collection<param variable>
    )
        /**
        configure vars
        **/
        var
            split
            =
            collection<param tag_e>
        var
            split
            =
            split(->)split "<"
        var
            split
            =
            split(->)split ">"
        /**
        parse
        **/
        var
            collection<param variable>->@TagName
            =
            split(->)[1]
        var
            collection<param variable>
            =
            split(->)[2]
    collection<end function>
}
collection<new class?XmlFunctions Xml>
=
NULL
/**
XmlDocumment
represents a xml documment
**/
collection<class XmlDocumment>
{
    /**
    doc
    the documment
    **/
    declare var<doc>: text
    /**
    init
    **/
    collection<function init>
    (
        /**
        documment
        the documment to managen (in text)
        **/
        collection<param documment>
    )
        /**
        configure vars
        **/
        var
            (this)->doc
            =
            collection<param documment>
        /**
        make a ""basics Lima++ operations""
        **/
        var
            container
            =
            (this)->doc
        var
            container
            ++^^
            "<documment>"
        var
            .cnd
            =
            container
            # -> true/false
        jf
            .invalid
        var
            container
            =
            (this)->doc
        var
            container
            ++^^
            "</documment>"
        var
            .cnd
            =
            container
            # -> true/false
        jf
            .invalid
        __endprog__
        /**
        .invalid
        if the documment is invalid
        **/
        section
        .invalid
        __endprog__
    collection<end function>
    /**
    get-tag
    get the tag of the current xml
    NOTE: posible cant valide the attributes
    **/
    collection<function get-tag>
    (
        /**
        tag
        the name of the tag
        **/
        collection<param tag>
    )
        /**
        validate the documment
        **/
        var
            container
            =
            (this)->doc
        var
            container
            ++^^
            "<documment>"
        var
            .cnd
            =
            container
            # -> true/false
        jf
            .invalid
        var
            container
            =
            (this)->doc
        var
            container
            ++^^
            "</documment>"
        var
            .cnd
            =
            container
            # -> true/false
        jf
            .invalid
        /**
        configure vars
        **/
        var
            index
            =
            0
        var
            blocks
        var
            line
            =
            prototype
        var
            lines
            =
            (this)->doc
        jump
        .xloop
        /**
        .loop
        recorres all xml array
        **/
        section
        .xloop
            /**
            check the conditions
            **/
            mov
                @bx
                lines(->)items_count
            var
                .cnd
                =
                (index==@bx)
            jt
                .invalid
            /**
            configure envioriment
            **/
            var
                line
                =
                lines(->)[index]
            /**
            trim it
            **/
            var
                line
                =
                line(->)trim
            /**
            parse the tag
            **/
            NULL collection<instance;class?XmlFunctions;Xml;parse_tag>(->)<line,tag>
            /**
            check it the tag
            **/
            var
                .cnd
                =
                (tag->@TagName==collection<param tag>)
            jt
                .founded!!!
            var
                index
                +=
                1
        jump
        .xloop
        section
        .next_item
            var
                index
                +=
                1
        jump
        .xloop
        section
        .founded!!!
            collection<return tag>
        section
        .invalid
            collection<return NULL>
        __endprog__
    collection<end function>
}